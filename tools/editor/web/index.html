<!-- pookie! -->
<html>
	<head>

	<title>Backfire Editor</title>

	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>

	<link rel="stylesheet" href="//code.jquery.com/ui/1.11.2/themes/trontastic/jquery-ui.css">
	<script src="//code.jquery.com/ui/1.11.2/jquery-ui.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.12/jquery.mousewheel.min.js"></script>
	<script src="editor.js"></script>

	<script language="javascript">

	var spritesheets = {};
	var animations = {};
	var textures = {};
	var offsetX = 0;
	var offsetY = 0;
	var canvas = null;
	var context = null;
	var dragStartX = 0;
	var dragStartY = 0;
	var dragX = 0;
	var dragY = 0;
	var isDragging = false;
	var scale = 1;

	function spriteSheetByName(name) {
		// console.log("getting spritesheet by name " + name);
		for (var i in spritesheets)
			if (spritesheets[i].name == name)
				return spritesheets[i];

		return null;
	}

	var frameIndex = 0;

	function drawCheckerBoard(context) {
		var blockWidth = 10;
		var blockHeight = 10;
		var colors = [
			'rgba(255, 255, 255, 1)', 
			'rgba(127, 127, 127, 1)'
		];
		var colorIndex =  0;

		context.fillStyle = colors[0];
		context.fillRect(0, 0, context.canvas.width, context.canvas.height);

		// prepare for drawing only every other color rect
		context.fillStyle = colors[1];

		var y = 0;
		var row = 0;
		while (y < context.canvas.height) {
			var x = 0;
			colorIndex = row % 2;
			while (x < context.canvas.width) {
				if (colorIndex == 1)
					context.fillRect(x, y, blockWidth, blockHeight);

				x += blockWidth;
				colorIndex++;
				colorIndex = colorIndex % 2;
			}
			y += blockHeight;
			row++;
		}
	}

	function drawCheckerBoard2(context) {
		var blockWidth = 750;
		var blockHeight = 449;

		var y = 0;
		var row = 0;
		while (y < context.canvas.height) {
			var x = 0;
			while (x < context.canvas.width) {
				context.drawImage(textures['grid.png'], x, y);
				x += blockWidth;
			}
			y += blockHeight;
		}
	}

	var draw = {};

	function showAnimation(anim) {
		draw.type = 'spritesheet';
		draw.spritesheet = spriteSheetByName(anim.frames[0].spriteSheet);
		console.log("drawing spritesheet");
		console.log(draw.spritesheet);
	}

	function drawSpriteSheetGrid() {
		context.strokeStyle = 'rgba(255, 255, 255, 0.6)';
		context.lineWidth = '1';
		var y = 0;
		while (y < textures[draw.spritesheet.texture].height) {
			var x = 0;
			while (x < textures[draw.spritesheet.texture].width) {
				x += draw.spritesheet.spriteWidth;

				if (x < textures[draw.spritesheet.texture].width) {
					context.moveTo(x, 0);
					context.lineTo(x, textures[draw.spritesheet.texture].height);
				}
			}
			y += draw.spritesheet.spriteHeight;

			if (y < textures[draw.spritesheet.texture].height) {
				context.moveTo(0, y);
				context.lineTo(textures[draw.spritesheet.texture].width, y);
			}
		}
	}

	function render() {
		canvas.width = canvas.width; // this one also clears strokes
		// context.clearRect(0, 0, canvas.width, canvas.height); // this one does not clear strokes

		drawCheckerBoard2(context);

		context.save();
		var s = scale;
		context.scale(s, s);
		context.translate(
			offsetX + (dragX - dragStartX) / s, 
			offsetY + (dragY - dragStartY) / s
		);
		if (draw.type == 'spritesheet') {
			if (draw.spritesheet.texture in textures) {
				context.fillStyle = 'rgba(0, 0, 0, 0.5)';
				context.fillRect(0, 0, textures[draw.spritesheet.texture].width, textures[draw.spritesheet.texture].height);
				context.drawImage(textures[draw.spritesheet.texture], 0, 0);

				// drawing lines when dragging affects the way lines look when moving the mouse
				// due to the low render framerate
				if (!isDragging) {
					drawSpriteSheetGrid();
				}
				frameIndex++;
			}
		}
		context.stroke();
		context.restore();
	}

	function initializeCanvas() {
		canvas = document.getElementById('canvas');
		context = canvas.getContext('2d');
		$(canvas)
			.mousedown(function(e) {
				isDragging = true;
				dragStartX = e.pageX;
				dragStartY = e.pageY;
				dragX = dragStartX;
				dragY = dragStartY;
				$(canvas).css('cursor', 'pointer');
			})
			.mouseup(function(e) {
				isDragging = false;
				offsetX += (dragX - dragStartX) / scale;
				offsetY += (dragY - dragStartY) / scale;
				dragStartX = dragStartY = dragX = dragY = 0;
				$(canvas).css('cursor', '');
			})
			.mousemove(function(e) {
				if (isDragging) {
					dragX = e.pageX;
					dragY = e.pageY;
				}
			})
			.mousewheel(function(e) {
				scale += e.deltaY*2 / e.deltaFactor;
				return false;
			});

		// setInterval(render, 20);
	}

	function populateAnimationList() {
		for (var i in animations)
			$('<div>')
				.addClass('animation')
				.data("animation", i)
				.text(animations[i].name)
				.appendTo($('#animations'))
				.click(function() {
					showAnimation(animations[$(this).data('animation')]);
				});
	}

	var texturesToLoad = 0;

	function preloadTexture(texture, takeRaw) {
		texturesToLoad++;
		var textureSrc = takeRaw ? '/' + texture : '/data/' + texture;
		var img = $('<img>').load(function() {
			textures[texture] = this;
			console.log('loaded ' + texture);
		}).attr('src', textureSrc);
	}

	function getAnimationByName(name) {
		for (var i in animations)
			if (animations[i].name == name)
				return animations[i];

		return null;
	}

	function addAnimationFrameInList(spriteSheetName, frameIndex) {
		// console.log('addAnimationFrameInList(' + spriteSheetName + ', ' + frameIndex + ')');
		var $li = $('<li>')
						.data('spritesheet-frame', frameIndex)
						.data('spritesheet-name', spriteSheetName)
						.appendTo($('#frames'));

		var spritesheet = spriteSheetByName(spriteSheetName);
		var spriteSheetFrame = spritesheet.frames[frameIndex];

		var $div = $('<div>')
			.data('spritesheet-frame', frameIndex)
			.data('spritesheet-name', spriteSheetName)
			.css('width', spritesheet.spriteWidth + 'px')
			.css('height', spritesheet.spriteHeight + 'px')
			.attr('title', spriteSheetName + '#' + frameIndex)
			.css('background-color', 'rgba(0, 0, 0, 0.7)')
			.css('background-image', 'url(/data/' + spritesheet.texture + ')')
			.css('background-position', '-' + spriteSheetFrame.x + 'px' + ' -' + spriteSheetFrame.y + 'px')
			.click(function() {
				$(this).parent().toggleClass('selected');
			})
			.appendTo($li);
	}

	function initializeFrameList(animation) {
		$('#frames').empty();
		if (animation != null)
			for (var i in animation.frames)
				addAnimationFrameInList(animation.frames[i].spriteSheet, animation.frames[i].index);
	}

	function calculateSpritesheetFrames() {
		for (var i in spritesheets) {
			spritesheets[i].frames = [];

			var spritesheet = spritesheets[i];
			var textureWidth = textures[spritesheet.texture].width;
			var textureHeight = textures[spritesheet.texture].height;
			var spriteWidth = spritesheet.spriteWidth;
			var spriteHeight = spritesheet.spriteHeight;

			var y = 0;
			while (y < textureHeight) {
				var x = 0;
				while (x < textureWidth) {
					spritesheets[i].frames[spritesheets[i].frames.length] = {
						'x': x,
						'y': y,
						'w': spriteWidth,
						'h': spriteHeight
					}
					x += spriteWidth;
				}
				y += spriteHeight;
			}

		}
	}

	function saveCurrentAnimationAs(name) {
		var previousName = editedAnimationName;
		var newFrames = [];
		$('#frames li').each(function() {
			newFrames[newFrames.length] = {
				'spriteSheet': $(this).data('spritesheet-name'),
				'index': $(this).data('spritesheet-frame')
			}
		})

		var isNewAnimation = previousName == '';
		if (isNewAnimation) {
			var animation = {
				'name': name,
				'frameTimeInMilliseconds': $('#animation-frame-delay').val(),
				'loopType': $('#animation-loop-type').val(),
				'frames': newFrames
			};
			animations[animations.length] = animation;

		} else {
			var animation = getAnimationByName(previousName);
			var nameChanged = previousName != name;
			if (nameChanged) {
				animation.name = name;
				console.log('!!!! TODO: update all recipe animation references from ' + previousName + ' to ' + name);
			}

			var newFrames = [];
			$('#frames li').each(function() {
				newFrames[newFrames.length] = {
					'spriteSheet': $(this).data('spritesheet-name'),
					'index': $(this).data('spritesheet-frame')
				}
			})
			animation.frameTimeInMilliseconds = $('#animation-frame-delay').val();
			animation.loopType = $('#animation-loop-type').val();
			animation.frames = newFrames;
		}
	}

	function initializeSpriteList(filter) {
		$('#sprites').empty();

		for (var i in spritesheets) {
			var spritesheet = spritesheets[i];
			if (filter == '' || filter == spritesheet.name) {
				for (var j in spritesheet.frames) {
					var $li = $('<li>')
									.data('spritesheet-frame', j)
									.data('spritesheet-name', spritesheet.name)
									.appendTo($('#sprites'));

					var spriteSheetFrame = spritesheet.frames[j];

					var $div = $('<div>')
						.data('spritesheet-frame', j)
						.data('spritesheet-name', spritesheet.name)
						.css('width', spritesheet.spriteWidth + 'px')
						.css('height', spritesheet.spriteHeight + 'px')
						.attr('title', spritesheet.nam + '#' + j)
						.css('background-color', 'rgba(0, 0, 0, 0.7)')
						.css('background-image', 'url(/data/' + spritesheet.texture + ')')
						.css('background-position', '-' + spriteSheetFrame.x + 'px' + ' -' + spriteSheetFrame.y + 'px')
						.click(function() {
							$(this).parent().toggleClass('selected');
						})
						.appendTo($li);
				}
			}
		}
	}


	function selectSprite(spriteSelectedCallback) {
		$filter = $('#spriteSheetFilter').empty();
		$('<option>').text('All').val('').appendTo($filter);
		for (var i in spritesheets)
			$('<option>')
				.text(spritesheets[i].name)
				.val(spritesheets[i].name)
				.appendTo($filter);

		$filter.change(function() {
			initializeSpriteList($(this).val());
		});

		initializeSpriteList('');

		$("#dlgSelectSprite").dialog({
			width: '1200',
			height: '600',
			modal: true,
			buttons: {
				Ok: function() {
					$('#sprites .selected').each(function() {
						spriteSelectedCallback(
							$(this).data('spritesheet-name'),
							$(this).data('spritesheet-frame')
						);
					});
					$(this).dialog("close");
				}
			}
		});
	}

	function drawCenteredSprite(ssName, ssFrame, context) {
		// console.log('ssname=' + ssName + ', ssframe=' + ssFrame);
		var ss = spriteSheetByName(ssName);
		if (ss == null)
			return;

		var frame = ss.frames[ssFrame];

		var centerX = context.canvas.width / 2;
		var centerY = context.canvas.height / 2;

		context.drawImage(
			textures[ss.texture], 
			frame.x, frame.y, 
			frame.w, frame.h, 
			centerX - frame.w / 2, centerY - frame.h / 2, 
			frame.w, frame.h
		);
	}

	var animationTime = 0;
	var animationFrameIndex = 0;
	var pingPongDirectionRight = true;
	function animateEditedAnimation() {
		var canvas = document.getElementById('animation-preview-canvas');
		var ctx = canvas.getContext('2d');

		animationTime += 33; // milliseconds in 30 FPS
		var animationFrameDelay = parseInt($('#animation-frame-delay').val());
		var animationLoopType = $('#animation-loop-type').val();

		while (animationTime > animationFrameDelay) {
			animationTime -= animationFrameDelay;

			switch (animationLoopType) {
				case 'FORWARD':
					animationFrameIndex++;
					animationFrameIndex %= $('#frames li').length;
					break;
				case 'REVERSE':
					animationFrameIndex--;
					if (animationFrameIndex < 0)
						animationFrameIndex = $('#frames li').length - 1;
					break;
				case 'PING_PONG':
					if (pingPongDirectionRight)
						animationFrameIndex++;
					else
						animationFrameIndex--;

					if (animationFrameIndex >= $('#frames li').length) {
						animationFrameIndex = $('#frames li').length - 2; // last frame has already been played
						pingPongDirectionRight = !pingPongDirectionRight;
					}

					if (animationFrameIndex < 0) {
						animationFrameIndex = 1; // first frame has already been played
						pingPongDirectionRight = !pingPongDirectionRight;
					}

					// final index sanitization since the index might be out of rage 
					if (animationFrameIndex < 0)
						animationFrameIndex = 0;

					if (animationFrameIndex >= $('#frames li').length)
						animationFrameIndex = 0;

					break;
				default:
					console.log('Unknown animation loop type ' + animationLoopType);
					break;
			}

		}

		// console.log(animationFrameIndex);
		ctx.width = ctx.width;

		ctx.fillStyle = 'rgb(0, 0, 0)';
		ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);


		$li = $('#frames li:eq(' + animationFrameIndex + ')');
		if ($li.length == 0)
			return;

		var ssName = $li.data('spritesheet-name');
		var ssFrame = $li.data('spritesheet-frame');

		drawCenteredSprite(ssName, ssFrame, ctx);
	}

	var editedAnimationName = '';
	function editAnimation(animationName) {
		editedAnimationName = animationName;
		var animation = getAnimationByName(animationName);
		if (animation == null) {
			$('#animation-name').val(animationName);
			$('#animation-loop-type').val('FORWARD');
			$('#animation-frame-delay').val('100');
		} else {
			$('#animation-name').val(animation.name);
			$('#animation-loop-type').val(animation.loopType);
			$('#animation-frame-delay').val(animation.frameTimeInMilliseconds);
		}

		initializeFrameList(animation);

		 $("#dlgAnimation").dialog({
		 	width: '1200',
		 	height: '560',
			modal: true,
			open: function() {
				var timer = setInterval(animateEditedAnimation, 1000 / 30); // at 30FPS
				$('#dlgAnimation').data('timer', timer);
			},
			close: function() {
				clearInterval($('#dlgAnimation').data('timer'));
			},
			buttons: {
				'Delete Selected': function() {
					$('#frames .selected').each(function() {
						$(this).remove();
					})
				},
				'Add Sprite': function() {
					var animation = getAnimationByName(animationName);
					selectSprite(function(spriteSheetName, frameIndex) {
						addAnimationFrameInList(spriteSheetName, frameIndex);
						animationTime = 0;
						animationFrameIndex = 0;
						pingPongDirectionRight = true;
					});
				},
				Ok: function() {
					saveCurrentAnimationAs($('#animation-name').val());
					$(this).dialog("close");
				}
			}
		});
	}

	function initializeEditor() {
		var allTexturesLoaded = Object.keys(textures).length == texturesToLoad;
		if (!allTexturesLoaded) {
			setTimeout(initializeEditor, 100);
			return;
		}
		console.log('All spritesheet textures loaded');

		preprocessAnimations();
		calculateSpritesheetFrames();
		populateAnimationList();
		initializeCanvas();

		$("#frames").sortable();
		$("#frames").disableSelection();		

		$('#btnAnimation').click(function() {
			editAnimation('');
		})
	}

	function unpackAnimationFrameRanges(animation) {
		var newFrames = [];
		for (var i in animation.frames) {
			if ("indexTo" in animation.frames[i]) {
				for (var j = animation.frames[i].index; j <= animation.frames[i].indexTo; j++) {
					newFrames[newFrames.length] = {
						'spriteSheet': animation.frames[i].spriteSheet,
						'index': j
					};
				}
			} else {
				newFrames[newFrames.length] = {
					'spriteSheet': animation.frames[i].spriteSheet,
					'index': animation.frames[i].index
				};
			}
		}
		animation.frames = newFrames;
	}

	function preprocessAnimations() {
		// Replace all indexTo - indexFrom frame ranges with individual frames
		// This will be optimized back before saving. (if needed)
		for (var i in animations)
			unpackAnimationFrameRanges(animations[i]);
	}

	$(document).ready(function() {
    	$("input[type=submit], input[type=button], a, button").button();

		$.getJSON("/data/animations.json", function(data) {
			console.log(data);
			spritesheets = data.spriteSheets;
			animations = data.animations;

			animations.sort(function(el1,el2){
				return el1.name == el2.name ? 0 : (el1.name < el2.name ? -1 : 1); 
			});

			preloadTexture("grid.png", true);
			for (var i in spritesheets)
				preloadTexture(spritesheets[i].texture, false);


			initializeEditor();
		});
	})

	</script>

	<style type="text/css">

	#animations {
		float: left;
		width: 10em;
	}

	.animation {
		float: left;
		width: 100%;
		clear: both;
		margin-bottom: 0.5em;
		cursor: pointer;
		background-color: rgba(30, 0, 30, 0.7);
	}

	canvas {
		float: left;
	}

	#frames {
		float: left;
		display: block;
		width: 770px;
		list-style-type: none;
		padding: 0;
		margin: 0;

		border-style: solid;
		border-width: 2px;
		border-top-color: rgb(100, 100, 100);
		border-left-color: rgb(100, 100, 100);
		border-right-color: rgb(200, 200, 200);
		border-bottom-color: rgb(200, 200, 200);

  		background-image: url(grid.png);

		height: 20em;
		overflow: auto;
		margin-right: 0.5em;
	}
	#frames li {
		display: block;
		float: left;
		margin-bottom: 1px;
		margin-right: 1px;
		cursor: pointer;
		/*background-image: url(grid.png)*/
		padding: 0.3em;
	}

	#sprites {
		float: left;
		display: block;
		width: 1100px;
		list-style-type: none;
		padding: 0;
		margin: 0;
		height: 20em;
		overflow: auto;
	}
	#sprites li {
		display: block;
		float: left;
		margin-bottom: 1px;
		margin-right: 1px;
		cursor: pointer;
		padding: 0.3em;
	}

	.selected {
		background-color: rgba(180, 120, 60, 0.7);
	}

	body {
		font-family: sans-serif;
		/*font-size: 20pt;*/
		background-color: #1A2127;
		color: rgba(255, 255, 255, 0.9);
	}

	a {
		color: #D7503C;
	}

	.holder {
		width: 30em;
		margin-left: auto;
		margin-right: auto;
		margin-top: 5em;
	}

	.form input {
		font-size: 20pt;
		background-color: #0D1319;
		border: none;
		padding: 0.2em;
		color: rgba(255, 255, 255, 0.8);
	}

	.note {
		padding-top: 10em;
		font-size: 0.85em;
	}

	.ui-tooltip {
		padding: 10px 20px;
		border: 0px;
		font: bold 0.6em "Helvetica Neue", Sans-Serif;
		background: black;
		background-color: #1A2127;
		color: rgba(255, 255, 255, 0.8);
  	}
  	h1 {
  		margin-bottom: 2em;
  	}

  	.dialog {
  		display: none;
  	}

  	#animation-editor-holder {
  		float: left;
  		width: 100%;
  		padding-top: 2em;
  	}

  	#animation-previewer {
  		float: left;
  	}

  	#animation-editor-sidebar {
  		float: left;
  		width: 20em;
/*  		background-color: red;
*/  	}
  	.row {
  		float: left;
  		width: 100%;
  		margin-bottom: 0.5em;
  	}

  	.label {
  		float: left;
  		width: 10em;
  	}

  	.field {
  		float: left;
  		width: 8em;
  	}

  	.field input {
  		float: left;
  		width: 100%;
  	}

  	.field select {
  		float: left;
  		width: 100%;
  	}

	</style>

	</head>
	<body>
		<div id="animations"></div>
		<canvas id="canvas" width="1024" height="768"></canvas>
		<input type="button" id="btnAnimation" value="Animation"/>


		<div id="dlgAnimation" class="dialog" title="Animation" >
			<div id="animation-editor-holder">
				<ul id="frames"></ul>
				<div id="animation-editor-sidebar">
					<div class="row">
						<div class="label">Name</div>
						<div class="field">
							<input type="text" id="animation-name" />
						</div>
					</div>
					<div class="row">
						<div class="label">Loop Type</div>
						<div class="field">
							<select id="animation-loop-type">
								<option value="NONE">NONE</option>
								<option value="FORWARD">FORWARD</option>
								<option value="REVERSE">REVERSE</option>
								<option value="PING_PONG">PING_PONG</option>
							</select>				
						</div>
					</div>
					<div class="row">
						<div class="label">Frame delay (ms)</div>
						<div class="field">
							<input type="text" id="animation-frame-delay" />
						</div>
					</div>
					<div id="animation-previewer">
						<canvas id="animation-preview-canvas" width="320" height="200"></canvas>
					</div>
				</div>
			</div>
		</div>

		<div id="dlgSelectSprite" class="dialog" title="Selecte sprite">
			<div style="margin-bottom: 1em;">
				Filter <select id="spriteSheetFilter"></select>
			</div>
			<ul id="sprites"></ul>
		</div>

	</body>
</html>
